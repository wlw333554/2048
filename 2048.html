<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title id="pageTitle">2048 - 经典数字拼图游戏</title>
  <!-- 外部资源引入 -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Mongolian&display=swap" rel="stylesheet">
  
  <!-- 添加网站图标 -->
  <link rel="icon" href="https://www.google.com/s2/favicons?sz=64&domain=2048game.com" type="image/png">
  
  <!-- Tailwind 配置 -->
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            monet: {
              light: '#e0c3fc',
              DEFAULT: '#8e2de2',
              dark: '#4a00e0',
              accent1: '#ffb6c1',
              accent2: '#add8e6',
              accent3: '#f0e68c',
              accent4: '#ffd700',
            },
          },
          fontFamily: {
            game: ['"Fredoka One"', 'cursive', 'sans-serif'],
            mongolian: ['"Noto Sans Mongolian"', 'Mongolian Baiti', 'sans-serif'],
          },
        },
      }
    }
  </script>
  
  <!-- 核心样式 -->
  <style>
    /* 基础重置与全局样式 */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      background-color: #f8f5ff;
      background-image: radial-gradient(#d8c5ff 1px, transparent 0);
      background-size: 30px 30px;
      min-height: 100vh;
      font-family: 'Fredoka One', cursive;
      touch-action: manipulation; /* 改为 manipulation 防止滚动但允许触摸 */
      transition: background-color 0.3s ease, color 0.3s ease;
    }
    .dark body {
      background-color: #1a1a2e;
      background-image: radial-gradient(#2a2a40 1px, transparent 0);
      color: #eaeaea;
    }
    
    /* 蒙古语特殊字体支持 */
    .mongolian-traditional {
      font-family: 'Noto Sans Mongolian', 'Mongolian Baiti', 'Microsoft PhagsPa', sans-serif;
      font-size: 1.1em;
      line-height: 1.4;
    }
    
    /* 游戏状态提示 */
    .game-status {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 50;
      text-align: center;
      padding: 1rem;
      border-radius: 0.75rem;
      background-color: rgba(142, 45, 226, 0.8);
      color: white;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease, transform 0.3s ease;
    }
    .game-status.active {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
      pointer-events: all; /* 激活时允许点击 */
    }
    
    /* 游戏棋盘样式 */
    .game-board {
      background-color: rgba(230, 210, 255, 0.7);
      border-radius: 1rem;
      padding: 1rem;
      position: relative;
      overflow: hidden;
      transition: transform 0.3s ease, box-shadow 0.3s ease, background-color 0.3s ease;
      width: 100%;
      height: 100%;
      z-index: 10;
    }
    .dark .game-board {
      background-color: rgba(44, 44, 84, 0.7);
    }
    .game-board:hover {
      transform: translateY(-8px);
      box-shadow: 0 12px 20px rgba(0, 0, 0, 0.15);
    }
    .game-board::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0) 50%, rgba(0,0,0,0.05) 100%);
      z-index: 1;
    }
    .dark .game-board::before {
      background: linear-gradient(135deg, rgba(255,255,255,0.05) 0%, rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 100%);
    }
    
    /* 棋盘格子样式 */
    .cell {
      position: absolute;
      border-radius: 0.75rem;
      background-color: rgba(255, 255, 255, 0.3);
      z-index: 5;
      transition: background-color 0.3s ease;
    }
    .dark .cell {
      background-color: rgba(60, 60, 80, 0.3);
    }
    
    /* 数字方块核心样式 */
    .tile {
      position: absolute;
      z-index: 20;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      border-radius: 0.75rem;
      transition: left 0.2s ease, top 0.2s ease, width 0.2s ease, height 0.2s ease;
      will-change: left, top, opacity;
    }
    
    /* 方块动画效果 */
    .tile-merged {
      animation: tile-merged 0.3s ease-in-out;
      z-index: 30;
    }
    .new-tile {
      animation: new-tile 0.3s ease-out;
    }
    
    /* 动画关键帧 */
    @keyframes tile-merged {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); box-shadow: 0 0 25px rgba(255, 215, 0, 0.8); }
      100% { transform: scale(1); }
    }
    @keyframes new-tile {
      0% { opacity: 0; transform: scale(0.8); }
      100% { opacity: 1; transform: scale(1); }
    }
    
    /* 方块颜色系统（按数值区分） */
    .tile-2 { background-color: rgba(230, 210, 255, 0.9); color: #5a3991; }
    .tile-4 { background-color: rgba(210, 180, 255, 0.9); color: #5a3991; }
    .tile-8 { background-color: rgba(255, 182, 193, 0.9); color: #ffffff; }
    .tile-16 { background-color: rgba(255, 160, 122, 0.9); color: #ffffff; }
    .tile-32 { background-color: rgba(255, 140, 0, 0.9); color: #ffffff; }
    .tile-64 { background-color: rgba(255, 105, 97, 0.9); color: #ffffff; }
    .tile-128 { background-color: rgba(255, 215, 0, 0.9); color: #ffffff; }
    .tile-256 { background-color: rgba(255, 215, 0, 0.95); color: #ffffff; box-shadow: 0 0 15px rgba(255, 215, 0, 0.5); }
    .tile-512 { background-color: rgba(255, 215, 0, 1); color: #ffffff; box-shadow: 0 0 20px rgba(255, 215, 0, 0.7); }
    .tile-1024 { background-color: rgba(255, 215, 0, 1); color: #ffffff; box-shadow: 0 0 25px rgba(255, 215, 0, 0.9); }
    .tile-2048 { background-color: rgba(255, 215, 0, 1); color: #ffffff; box-shadow: 0 0 30px rgba(255, 215, 0, 1); }
    .tile-super { background-color: rgba(128, 0, 128, 0.9); color: #ffffff; box-shadow: 0 0 35px rgba(128, 0, 128, 0.7); }
    
    /* 深色模式方块颜色适配 */
    .dark .tile-2 { background-color: rgba(170, 150, 255, 0.9); color: #e0e0ff; }
    .dark .tile-4 { background-color: rgba(150, 120, 255, 0.9); color: #e0e0ff; }
    .dark .tile-8 { background-color: rgba(255, 150, 160, 0.9); color: #ffffff; }
    .dark .tile-16 { background-color: rgba(255, 140, 100, 0.9); color: #ffffff; }
    .dark .tile-32 { background-color: rgba(255, 120, 0, 0.9); color: #ffffff; }
    .dark .tile-64 { background-color: rgba(255, 90, 80, 0.9); color: #ffffff; }
    .dark .tile-128 { background-color: rgba(255, 200, 0, 0.9); color: #ffffff; }
    .dark .tile-256 { background-color: rgba(255, 200, 0, 0.95); color: #ffffff; box-shadow: 0 0 15px rgba(255, 200, 0, 0.6); }
    .dark .tile-512 { background-color: rgba(255, 200, 0, 1); color: #ffffff; box-shadow: 0 0 20px rgba(255, 200, 0, 0.8); }
    .dark .tile-1024 { background-color: rgba(255, 200, 0, 1); color: #ffffff; box-shadow: 0 0 25px rgba(255, 200, 0, 1); }
    .dark .tile-2048 { background-color: rgba(255, 200, 0, 1); color: #ffffff; box-shadow: 0 0 30px rgba(255, 200, 0, 1.2); }
    .dark .tile-super { background-color: rgba(150, 30, 150, 0.9); color: #ffffff; box-shadow: 0 0 35px rgba(150, 30, 150, 0.8); }
    
    /* 按钮交互效果 */
    .btn-hover {
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
    }
    .btn-hover::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: all 0.6s ease;
    }
    .btn-hover:hover::after {
      left: 100%;
    }
    .btn-hover:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(142, 45, 226, 0.3);
    }
    .btn-hover:active {
      transform: translateY(0);
    }
    
    /* 分数变化动画 */
    .score-change {
      animation: score-change 0.5s ease-in-out;
    }
    @keyframes score-change {
      0% { transform: scale(1); color: #8e2de2; }
      50% { transform: scale(1.2); color: #ffd700; }
      100% { transform: scale(1); color: #8e2de2; }
    }
    
    /* 模态框基础样式 */
    .modal {
      background-color: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(5px);
      transition: opacity 0.3s ease, visibility 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }
    .modal.active {
      opacity: 1;
      visibility: visible;
      pointer-events: all;
    }
    .modal-content {
      background-color: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      transition: transform 0.3s ease, background-color 0.3s ease;
      width: 100%;
      max-width: 320px;
      max-height: 90vh;
      position: relative;
      border-radius: 1rem;
      transform: scale(0.95);
      overflow: hidden;
    }
    .modal.active .modal-content {
      transform: scale(1);
    }
    .dark .modal-content {
      background-color: rgba(30, 30, 50, 0.95);
      color: #eaeaea;
    }
    
    /* 开关按钮基础样式 */
    .theme-switch {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 34px;
    }
    .theme-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 34px;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 26px;
      width: 26px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    input:checked + .slider {
      background-color: #8e2de2;
    }
    input:checked + .slider:before {
      transform: translateX(26px);
    }
    
    /* 语言选项按钮动画效果 */
    .language-option {
      transition: all 0.2s ease;
    }
    .language-option:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 4px 12px rgba(142, 45, 226, 0.2);
    }
    .language-option.active {
      background-color: #8e2de2;
      color: white;
    }
    
    /* 游戏难度滑动条样式 */
    input[type="range"].difficulty-slider {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 8px;
      border-radius: 5px;
      background: #e0c3fc;
      outline: none;
    }
    input[type="range"].difficulty-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #8e2de2;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    input[type="range"].difficulty-slider::-webkit-slider-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 0 10px rgba(142, 45, 226, 0.6);
    }
    input[type="range"].difficulty-slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #8e2de2;
      cursor: pointer;
      border: none;
      transition: all 0.2s ease;
    }
    input[type="range"].difficulty-slider::-moz-range-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 0 10px rgba(142, 45, 226, 0.6);
    }
    .dark input[type="range"].difficulty-slider {
      background: #4a00e0;
    }
  </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4 md:p-8">
  
  <!-- 游戏容器 -->
  <div class="w-full max-w-md mx-auto flex flex-col items-center gap-6">
    
    <!-- 游戏标题 -->
    <div class="w-full flex justify-between items-center">
      <h1 class="text-[clamp(2.5rem,8vw,4rem)] font-game font-bold text-monet-dark text-shadow">
        2048
      </h1>
      <div class="flex gap-2">
        <button id="howToPlayBtn" class="acrylic px-4 py-2 rounded-full text-monet-dark font-semibold flex items-center gap-2 hover:bg-white/30 transition-all btn-hover">
          <i class="fa fa-question-circle"></i>
          <span class="hidden sm:inline" data-i18n="howToPlay">玩法</span>
        </button>
        <button id="settingsBtn" class="acrylic px-4 py-2 rounded-full text-monet-dark font-semibold flex items-center gap-2 hover:bg-white/30 transition-all btn-hover">
          <i class="fa fa-cog"></i>
          <span class="hidden sm:inline" data-i18n="settings">设置</span>
        </button>
        <button id="restartBtn" class="acrylic px-4 py-2 rounded-full text-monet-dark font-semibold flex items-center gap-2 hover:bg-white/30 transition-all btn-hover">
          <i class="fa fa-refresh"></i>
          <span class="hidden sm:inline" data-i18n="restart">重来</span>
        </button>
      </div>
    </div>
    
    <!-- 分数面板 -->
    <div class="w-full flex justify-between gap-4 mb-2">
      <div class="acrylic flex-1 p-3 rounded-xl flex flex-col items-center">
        <div class="text-sm text-monet-dark font-medium" data-i18n="score">得分</div>
        <div id="score" class="text-2xl font-bold text-monet-dark">0</div>
      </div>
      <div class="acrylic flex-1 p-3 rounded-xl flex flex-col items-center">
        <div class="text-sm text-monet-dark font-medium" data-i18n="bestScore">最高分</div>
        <div id="bestScore" class="text-2xl font-bold text-monet-dark">0</div>
      </div>
    </div>
    
    <!-- 游戏棋盘容器 -->
    <div id="gameContainer" class="relative w-full aspect-square max-w-md mx-auto" tabindex="0" style="outline: none;">
      <div id="gameBoard" class="game-board">
        <!-- 游戏状态提示 -->
        <div id="gameStatus" class="game-status text-xl font-bold">
          <p id="gameStatusText" class="mb-2"></p>
          <button id="gameStatusBtn" class="bg-white text-monet px-4 py-2 rounded-full font-bold hover:bg-monet-dark hover:text-white transition-all btn-hover">
            继续游戏
          </button>
        </div>
        <!-- 格子和方块将通过JS动态生成 -->
      </div>
    </div>
    
    <!-- 游戏操作提示 -->
    <div class="w-full text-center mt-4 text-monet-dark/80">
      <p class="text-sm mb-2" data-i18n="keyboardHint">使用 <span class="font-bold">↑ ↓ ← →</span> 或 <span class='font-bold'>WASD</span> 移动方块</p>
      <p class="text-sm" data-i18n="touchHint">或在触摸屏上 <span class='font-bold'>滑动</span> 移动</p>
    </div>
  </div>
  
  <!-- 游戏说明模态框 -->
  <div id="howToPlayModal" class="modal">
    <div class="modal-content">
      <div class="p-6">
        <div class="flex justify-between items-center mb-4">
          <h3 class="text-2xl font-bold text-monet-dark" data-i18n="howToPlayTitle">如何玩2048</h3>
          <button id="closeHowToPlayModalBtn" class="text-monet-dark text-xl hover:text-monet">
            <i class="fa fa-times"></i>
          </button>
        </div>
        <div class="space-y-4 text-monet-dark/90">
          <p data-i18n="howToPlayDesc1">使用方向键或WASD键移动方块，相同数字的方块会合并成为它们的和。</p>
          <p data-i18n="howToPlayDesc2">每次移动后会随机生成一个新的2或4方块。</p>
          <p data-i18n="howToPlayDesc3">尝试创造更高的分数！</p>
        </div>
        <button id="startPlayingBtn" class="w-full mt-6 bg-monet text-white py-3 rounded-full font-bold hover:bg-monet-dark transition-all btn-hover" data-i18n="startPlaying">
          开始游戏
        </button>
      </div>
    </div>
  </div>
  
  <!-- 设置模态框 -->
  <div id="settingsModal" class="modal">
    <div class="modal-content rounded-2xl p-6 max-w-md w-full mx-4">
      <div class="flex justify-between items-center mb-4">
        <h3 class="text-2xl font-bold text-monet-dark" data-i18n="settingsTitle">游戏设置</h3>
        <button id="closeSettingsModalBtn" class="text-monet-dark text-xl hover:text-monet">
          <i class="fa fa-times"></i>
        </button>
      </div>
      <div class="settings-scroll overflow-y-auto pb-4 max-h-[60vh]">
        <div class="flex flex-col gap-6 min-w-full">
          <!-- 语言选择选项 -->
          <div class="p-4 bg-white/50 dark:bg-white/5 rounded-xl">
            <div class="flex items-center gap-3 mb-3">
              <i class="fa fa-globe text-2xl text-monet-dark"></i>
              <span class="text-lg" data-i18n="language">语言 / Language</span>
            </div>
            <div class="language-selector flex flex-wrap gap-2">
              <div class="language-option active px-4 py-2 rounded-full text-center cursor-pointer transition-all" data-lang="zh">中文简体</div>
              <div class="language-option px-4 py-2 rounded-full text-center cursor-pointer transition-all" data-lang="zh-TW">中文繁體</div>
              <div class="language-option px-4 py-2 rounded-full text-center cursor-pointer transition-all" data-lang="en">English</div>
              <div class="language-option px-4 py-2 rounded-full text-center cursor-pointer transition-all" data-lang="ja">日本語</div>
              <div class="language-option px-4 py-2 rounded-full text-center cursor-pointer transition-all mongolian-traditional" data-lang="mn-Mong" style="font-feature-settings: 'kern' 1, 'liga' 1;">ᠮᠣᠩᠭᠣᠯ</div>
            </div>
          </div>
          
          <!-- 主题切换选项 -->
          <div class="p-4 bg-white/50 dark:bg-white/5 rounded-xl">
            <div class="flex items-center justify-between mb-2">
              <div class="flex items-center gap-3">
                <i class="fa fa-moon-o text-2xl text-monet-dark"></i>
                <span class="text-lg" data-i18n="darkMode">深色模式</span>
              </div>
              <label class="theme-switch">
                <input type="checkbox" id="themeToggle">
                <span class="slider"></span>
              </label>
            </div>
            <p class="text-sm text-monet-dark/80 mt-2" data-i18n="darkModeDesc">切换游戏的视觉主题。深色模式使用深色背景和高对比度元素，适合夜间或低光环境，可减轻眼睛疲劳。</p>
          </div>
          
          <!-- 游戏难度滑动条 -->
          <div class="p-4 bg-white/50 dark:bg-white/5 rounded-xl">
            <div class="flex items-center justify-between mb-4">
              <div class="flex items-center gap-3">
                <i class="fa fa-tachometer text-2xl text-monet-dark"></i>
                <span class="text-lg" data-i18n="difficulty">游戏难度</span>
              </div>
              <span id="difficultyValue" class="px-3 py-1 bg-monet/20 rounded-full text-sm font-medium" data-i18n="difficultyMedium">中等</span>
            </div>
            <input type="range" min="1" max="3" value="2" class="difficulty-slider" id="difficultySlider">
            <div class="flex justify-between mt-2 text-xs text-monet-dark/70">
              <span data-i18n="difficultyEasy">简单</span>
              <span data-i18n="difficultyMedium">中等</span>
              <span data-i18n="difficultyHard">困难</span>
            </div>
            <p class="text-sm text-monet-dark/80 mt-3" data-i18n="difficultyDesc">调整游戏难度会影响初始方块数量和生成新方块的概率。简单模式更容易上手，困难模式更具挑战性。</p>
          </div>
          
          <!-- 关闭动画效果选项 -->
          <div class="p-4 bg-white/50 dark:bg-white/5 rounded-xl">
            <div class="flex items-center justify-between mb-2">
              <div class="flex items-center gap-3">
                <i class="fa fa-film text-2xl text-monet-dark"></i>
                <span class="text-lg" data-i18n="disableAnimations">关闭动画效果</span>
              </div>
              <label class="theme-switch">
                <input type="checkbox" id="disableAnimationsToggle">
                <span class="slider"></span>
              </label>
            </div>
            <p class="text-sm text-monet-dark/80 mt-2" data-i18n="disableAnimationsDesc">禁用游戏中的部分动画效果，包括方块移动、合并和新方块出现的动画。会牺牲视觉体验。仅在设备性能较差时考虑开启。</p>
          </div>
        </div>
      </div>
      <button id="closeSettingsBtn" class="mt-6 w-full bg-monet text-white py-3 rounded-full font-bold hover:bg-monet-dark transition-all btn-hover" data-i18n="close">
        关闭
      </button>
    </div>
  </div>

  <script>
    // --- 语言系统 ---
    const translations = {
      en: {
        howToPlay: "How to Play",
        settings: "Settings",
        restart: "Restart",
        score: "Score",
        bestScore: "Best Score",
        keyboardHint: "Use <span class='font-bold'>↑ ↓ ← →</span> or <span class='font-bold'>WASD</span> to move tiles",
        touchHint: "Or <span class='font-bold'>swipe</span> on touch screens",
        howToPlayTitle: "How to Play 2048",
        howToPlayDesc1: "Use arrow keys or WASD to move tiles. Tiles with the same number merge into one when they touch.",
        howToPlayDesc2: "A new tile (2 or 4) will randomly appear after each move.",
        howToPlayDesc3: "Try to create a higher score!",
        startPlaying: "Start Playing",
        settingsTitle: "Game Settings",
        language: "Language",
        darkMode: "Dark Mode",
        darkModeDesc: "Switch the visual theme of the game. Dark mode uses a dark background and high-contrast elements, suitable for night or low-light environments and can reduce eye strain.",
        difficulty: "Difficulty",
        difficultyEasy: "Easy",
        difficultyMedium: "Medium",
        difficultyHard: "Hard",
        difficultyDesc: "Adjusting the difficulty affects the number of initial tiles and the probability of generating new tiles. Easy mode is more accessible, while hard mode is more challenging.",
        disableAnimations: "Disable Animations",
        disableAnimationsDesc: "Disable some animation effects in the game, including tile movement, merging, and new tile appearance animations. This will sacrifice visual experience. Only consider enabling it if your device has poor performance.",
        close: "Close",
        gameWon: "You Win!",
        gameWonDesc: "You've reached 2048!",
        keepPlaying: "Keep Playing",
        newGame: "New Game",
        gameOver: "Game Over!",
        gameOverDesc: "No more moves available!"
      },
      zh: {
        howToPlay: "玩法",
        settings: "设置",
        restart: "重来",
        score: "得分",
        bestScore: "最高分",
        keyboardHint: "使用 <span class='font-bold'>↑ ↓ ← →</span> 或 <span class='font-bold'>WASD</span> 移动方块",
        touchHint: "或在触摸屏上 <span class='font-bold'>滑动</span> 移动",
        howToPlayTitle: "如何玩2048",
        howToPlayDesc1: "使用方向键或WASD键移动方块，相同数字的方块会合并成为它们的和。",
        howToPlayDesc2: "每次移动后会随机生成一个新的2或4方块。",
        howToPlayDesc3: "尝试创造更高的分数！",
        startPlaying: "开始游戏",
        settingsTitle: "游戏设置",
        language: "语言",
        darkMode: "深色模式",
        darkModeDesc: "切换游戏的视觉主题。深色模式使用深色背景和高对比度元素，适合夜间或低光环境，可减轻眼睛疲劳。",
        difficulty: "游戏难度",
        difficultyEasy: "简单",
        difficultyMedium: "中等",
        difficultyHard: "困难",
        difficultyDesc: "调整游戏难度会影响初始方块数量和生成新方块的概率。简单模式更容易上手，困难模式更具挑战性。",
        disableAnimations: "关闭动画效果(实验性)",
        disableAnimationsDesc: "禁用游戏中的部分动画效果，包括方块移动、合并和新方块出现的动画。会牺牲视觉体验。仅在设备性能较差时考虑开启。",
        close: "关闭",
        gameWon: "你赢了!",
        gameWonDesc: "你已经合成了2048!",
        keepPlaying: "继续游戏",
        newGame: "新游戏",
        gameOver: "游戏结束!",
        gameOverDesc: "无法再移动方块了!"
      },
      "zh-TW": {
        howToPlay: "玩法",
        settings: "設定",
        restart: "重來",
        score: "得分",
        bestScore: "最高分",
        keyboardHint: "使用 <span class='font-bold'>↑ ↓ ← →</span> 或 <span class='font-bold'>WASD</span> 移動方塊",
        touchHint: "或在觸控螢幕上 <span class='font-bold'>滑動</span> 移動",
        howToPlayTitle: "如何玩2048",
        howToPlayDesc1: "使用方向鍵或WASD鍵移動方塊，相同數字的方塊會合併成為它們的和。",
        howToPlayDesc2: "每次移動後會隨機生成一個新的2或4方塊。",
        howToPlayDesc3: "嘗試創造更高的分數！",
        startPlaying: "開始遊戲",
        settingsTitle: "遊戲設定",
        language: "語言",
        darkMode: "深色模式",
        darkModeDesc: "切換遊戲的視覺主題。深色模式使用深色背景和高對比度元素，適合夜間或低光環境，可減輕眼睛疲勞。",
        difficulty: "遊戲難度",
        difficultyEasy: "簡單",
        difficultyMedium: "中等",
        difficultyHard: "困難",
        difficultyDesc: "調整遊戲難度會影響初始方塊數量和生成新方塊的機率。簡單模式更容易上手，困難模式更具挑戰性。",
        disableAnimations: "關閉動畫效果",
        disableAnimationsDesc: "禁用遊戲中的部分動畫效果，包括方塊移動、合併和新方塊出現的動畫。會犧牲視覺體驗。僅在設備效能較差時考慮開啟。",
        close: "關閉",
        gameWon: "你贏了!",
        gameWonDesc: "你已經合成了2048!",
        keepPlaying: "繼續遊戲",
        newGame: "新遊戲",
        gameOver: "遊戲結束!",
        gameOverDesc: "無法再移動方塊了!"
      },
      ja: {
        howToPlay: "遊び方",
        settings: "設定",
        restart: "再スタート",
        score: "スコア",
        bestScore: "ベストスコア",
        keyboardHint: "<span class='font-bold'>↑ ↓ ← →</span> キーまたは <span class='font-bold'>WASD</span> キーでタイルを移動",
        touchHint: "またはタッチスクリーンで <span class='font-bold'>スワイプ</span> して移動",
        howToPlayTitle: "2048の遊び方",
        howToPlayDesc1: "矢印キーまたはWASDキーを使用してタイルを移動させます。同じ数字のタイルが接触すると、それらは合体して合計になります。",
        howToPlayDesc2: "毎回移動した後、ランダムに新しい2または4のタイルが生成されます。",
        howToPlayDesc3: "より高いスコアを目指しましょう！",
        startPlaying: "ゲームを始める",
        settingsTitle: "ゲーム設定",
        language: "言語",
        darkMode: "ダークモード",
        darkModeDesc: "ゲームの視覚的なテーマを切り替えます。ダークモードは暗い背景と高コントラストの要素を使用し、夜間や低照度環境に適しており、目の疲れを軽減できます。",
        difficulty: "ゲーム難易度",
        difficultyEasy: "簡単",
        difficultyMedium: "普通",
        difficultyHard: "難しい",
        difficultyDesc: "難易度を調整すると、初期タイルの数と新しいタイルが生成される確率に影響します。簡単モードは初心者にやさしく、難しいモードはより挑戦的です。",
        disableAnimations: "アニメーション効果をオフにする",
        disableAnimationsDesc: "ゲーム内の一部のアニメーション効果（タイルの移動、合体、新しいタイルの出現など）を無効にします。視覚的な体験が犠牲になります。デバイスのパフォーマンスが低い場合にのみ考慮してください。",
        close: "閉じる",
        gameWon: "あなたの勝ち!",
        gameWonDesc: "あなたは2048を合成しました!",
        keepPlaying: "続けて遊ぶ",
        newGame: "新しいゲーム",
        gameOver: "ゲームオーバー!",
        gameOverDesc: "これ以上移動できません!"
      },
      "mn-Mong": {
        howToPlay: "ᠲ᠋ᠤᠭ᠋ᠯᠠᠬᠤ ᠠᠷᠭᠠ",
        settings: "ᠲ᠋ᠣᠬᠢᠷᠭᠠ",
        restart: "ᠳᠠᠬᠢᠨ ᠡᠬᠡᠯᠡᠬᠦ",
        score: "ᠣᠨᠣᠭᠠ",
        bestScore: "ᠳᠡᠭᠡᠳᠦ ᠣᠨᠣᠭᠠ",
        keyboardHint: "<span class='font-bold'>↑ ↓ ← →</span> ᠡᠰᠡᠭᠡᠯᠡ ᠪᠦ᠋ <span class='font-bold'>WASD</span> ᠲᠣᠪᠴᠢᠭᠤᠳ ᠢᠶᠡᠨ ᠬᠥᠳᠡᠯᠭᠡᠨᠡ",
        touchHint: "ᠡᠰᠡᠭᠡᠯᠡ ᠮᠡᠳᠡᠷᠡᠭᠡᠴᠡ ᠳᠡᠯᠡᠭᠡᠴᠡ ᠳᠡ <span class='font-bold'>ᠱᠦᠦᠷᠡᠨ</span> ᠬᠥᠳᠡᠯᠭᠡᠨᠡ",
        howToPlayTitle: "2048 ᠬᠡᠷᠡᠭᠬᠡ ᠲᠤᠭᠯᠠᠬᠤ",
        howToPlayDesc1: "ᠰᠤᠮᠤᠨ ᠦ ᠲᠣᠪᠴᠢᠭ ᠡᠰᠡᠭᠡᠯᠡ ᠪᠦ᠋ ᠪᠦ᠋ WASD ᠲᠣᠪᠴᠢᠭᠤᠳ ᠢᠶᠡᠨ ᠬᠥᠳᠡᠯᠭᠡᠨᠡ. ᠢᠵᠢᠯ ᠲᠣᠭᠠᠲᠠᠢ ᠬᠡᠰᠡᠭᠡᠨᠦᠳ ᠬᠡᠰᠡᠭᠡᠨᠦᠳ ᠬᠦᠷᠡᠯᠴᠡᠬᠦ ᠦᠭᠡᠢ ᠨᠡᠢᠭᠡᠳᠦᠭᠰᠡᠨᠡ.",
        howToPlayDesc2: "ᠬᠥᠳᠡᠯᠭᠡ ᠪᠦᠷᠢᠶᠡᠨ ᠦ ᠳᠠᠷᠠᠭᠠ 2 ᠡᠰᠡᠭᠡᠯᠡ ᠪᠦ᠋ 4 ᠲᠣᠭᠠᠲᠠᠢ ᠰᠢᠨᠡ ᠬᠡᠰᠡᠭᠡᠨᠦᠳ ᠰᠠᠨᠠᠮᠰᠠᠷᠭᠤᠭᠤᠯᠬᠤ ᠭᠠᠷᠴᠠᠬᠤ.",
        howToPlayDesc3: "ᠢᠯᠦᠭᠡ ᠥᠨᠳᠥᠷ ᠣᠨᠣᠭᠠ ᠠᠪᠬᠤᠷᠠᠵᠤ ᠺᠢᠴᠡᠭᠡᠨᠡ!",
        startPlaying: "ᠲᠤᠭᠯᠠᠬᠤ",
        settingsTitle: "ᠲᠤᠭᠯᠣᠮ ᠦ ᠲᠣᠬᠢᠷᠭᠠ",
        language: "ᠺᠡᠯᠡ",
        darkMode: "ᠬᠠᠷᠠᠩᠬᠤᠢ ᠭᠣᠷᠢᠮ",
        darkModeDesc: "ᠲᠤᠭᠯᠣᠮ ᠦ ᠺᠠᠷᠠᠭᠳᠠᠴᠢ ᠥᠩᠭᠡ ᠦ ᠵᠠᠭᠤᠯᠢ ᠪᠠᠢᠴᠠᠭᠠᠨᠠ. ᠬᠠᠷᠠᠩᠬᠤᠢ ᠭᠣᠷᠢᠮ ᠨᠦ᠋ ᠬᠠᠷᠠᠩᠬᠤᠢ ᠳᠡᠪᠡᠰᠡᠷ ᠥᠩᠭᠡ ᠥᠨᠳᠥᠷ ᠺᠣᠨᠲ᠋ᠷᠠᠰᠲᠲᠠᠢ ᠡᠯᠡᠮᠡᠨᠲᠦᠳ ᠠᠴᠢᠬᠤ ᠪᠦ᠋ᠡᠨᠡ ᠱᠥᠨᠢ ᠦ ᠴᠠᠭ ᠡᠰᠡᠭᠡᠯᠡ ᠺᠡᠷᠡᠭᠡᠨᠢ ᠴᠠᠭᠠᠨ ᠣᠷᠴᠢᠨ ᠲᠣᠭᠤᠷᠬᠠᠮᠲᠤ ᠲᠣᠭᠤᠮᠲᠠᠯᠴᠠᠬᠤ ᠪᠦ᠋ᠡᠨᠡ ᠨᠦᠳᠡᠨ ᠦ ᠶᠠᠳᠠᠯᠭᠠᠯᠲᠠ ᠪᠠᠭᠤᠵᠤ ᠲᠠᠭᠠᠭᠠᠴᠢᠯᠠᠨᠡ.",
        difficulty: "ᠺᠡᠴᠦᠭᠡ ᠪᠠᠢᠳᠠᠯ",
        difficultyEasy: "ᠠᠮᠠᠷᠬᠠᠨ",
        difficultyMedium: "ᠳᠤᠩᠳ ᠵᠡᠷᠡᠭ",
        difficultyHard: "ᠺᠡᠴᠦᠭᠡ",
        difficultyDesc: "ᠺᠡᠴᠦᠭᠡ ᠪᠠᠢᠳᠠᠯ ᠢᠶᠡᠨ ᠲᠣᠬᠢᠷᠭᠠᠬᠤ ᠨᠦ᠋ ᠠᠩᠬᠠᠨ ᠦ ᠬᠡᠰᠡᠭᠡᠨᠦᠳ ᠦᠨ ᠲᠣᠭᠠ ᠪᠦ᠋ᠡᠨᠡ ᠰᠢᠨᠡ ᠬᠡᠰᠡᠭᠡᠨᠦᠳ ᠦᠨ ᠮᠠᠭᠠᠳᠠᠯ ᠳᠡᠳ ᠨᠣᠯᠤᠭᠠᠳᠬᠤ. ᠠᠮᠠᠷᠬᠠᠨ ᠭᠣᠷᠢᠮ ᠨᠦ᠋ ᠡᠬᠡᠯᠡᠭᠡᠳᠲᠦᠷ ᠲᠣᠭᠤᠷᠬᠠᠮᠲᠤ ᠲᠣᠭᠤᠮᠲᠠᠯᠴᠠᠬᠤ ᠪᠦ᠋ᠡᠨᠡ ᠺᠡᠴᠦᠭᠡ ᠭᠣᠷᠢᠮ ᠨᠦ᠋ ᠢᠯᠦᠭᠡ ᠰᠣᠷᠢᠯᠭᠠᠯᠲᠠᠲᠠᠢ ᠪᠠᠢᠨᠠ.",
        disableAnimations: "ᠺᠥᠳᠡᠯᠭᠡᠨ ᠦ ᠢᠳᠡᠪᠬᠬᠢᠷᠭᠠᠬᠤ",
        disableAnimationsDesc: "ᠲᠤᠭᠯᠣᠮ ᠳᠠᠷᠠᠭᠠ ᠺᠥᠳᠡᠯᠭᠡᠨ ᠦ ᠡᠸᠧᠺᠲᠢᠶᠡᠨ ᠢᠳᠡᠪᠬᠬᠢᠷᠭᠠᠨᠡ. ᠦᠨᠳᠡᠰ ᠳᠡ ᠬᠡᠰᠡᠭᠡᠨᠦᠳ ᠦᠨ ᠺᠥᠳᠡᠯᠭᠡᠨ ᠨᠡᠢᠭᠡᠳᠦᠭᠰᠡᠨᠡ ᠪᠦ᠋ᠡᠨᠡ ᠰᠢᠨᠡ ᠬᠡᠰᠡᠭᠡᠨᠦᠳ ᠭᠠᠷᠴᠠᠬᠤ ᠺᠥᠳᠡᠯᠭᠡᠨ ᠦᠨᠳᠡᠰ ᠪᠠᠭᠤᠵᠤ ᠲᠠᠭᠠᠭᠠᠴᠢᠯᠠᠨᠡ. ᠨᠦ᠋ ᠺᠠᠷᠠᠭᠳᠠᠴᠢ ᠪᠠᠢᠳᠠᠯ ᠢᠶᠡᠨ ᠪᠠᠭᠤᠵᠤ ᠲᠠᠭᠠᠭᠠᠴᠢᠯᠠᠨᠡ. ᠳᠠᠨᠢᠮᠳᠠᠷ ᠲᠥᠬᠥᠺᠣᠷᠣᠮᠵᠢ ᠦᠨ ᠭᠦᠨᠴᠢᠭᠡᠨ ᠮᠤᠤ ᠪᠠᠢᠨᠠ ᠪᠣᠯ ᠢᠳᠡᠪᠬᠬᠢᠷᠭᠠᠵᠤ ᠰᠠᠨᠠᠵᠤ ᠪᠠᠢᠭᠰᠠᠨᠡ.",
        close: "ᠺᠠᠬᠤ",
        gameWon: "ᠲᠠ ᠺᠣᠵᠢᠯᠠ!",
        gameWonDesc: "ᠲᠠ 2048-ᠢᠢ ᠺᠦᠷᠲᠡᠯᠡ!",
        keepPlaying: "ᠦᠷᠭᠡᠯᠡᠯᠡᠬᠦ",
        newGame: "ᠰᠢᠨᠡ ᠲᠤᠭᠯᠣᠮ",
        gameOver: "ᠲᠤᠭᠯᠣᠮ ᠳᠤᠲᠠᠭᠠᠯᠠᠬᠤ!",
        gameOverDesc: "ᠨᠡᠮᠡᠬᠦ ᠺᠥᠳᠡᠯᠭᠡᠨ ᠤᠯᠤᠰ ᠪᠠᠢᠭᠤᠯᠬᠤᠭᠠ!"
      }
    };

    // --- 工具函数 ---
    const utils = {
      /**
       * 获取DOM元素
       * @param {string} selector - CSS选择器
       * @returns {HTMLElement} DOM元素
       */
      getElement(selector) {
        return document.querySelector(selector);
      },

      /**
       * 获取多个DOM元素
       * @param {string} selector - CSS选择器
       * @returns {NodeList} DOM元素列表
       */
      getElements(selector) {
        return document.querySelectorAll(selector);
      },

      /**
       * 打开模态框
       * @param {string} modalId - 模态框ID
       */
      openModal(modalId) {
        const modal = this.getElement(`#${modalId}`);
        if (modal) {
          modal.classList.add('active');
        }
      },

      /**
       * 关闭模态框
       * @param {string} modalId - 模态框ID
       */
      closeModal(modalId) {
        const modal = this.getElement(`#${modalId}`);
        if (modal) {
          modal.classList.remove('active');
          setTimeout(() => this.getElement('#gameContainer').focus(), 300);
        }
      },

      /**
       * 显示游戏状态提示
       * @param {string} status - 状态类型 ('won', 'gameOver')
       */
      showGameStatus(status) {
        const statusElement = this.getElement('#gameStatus');
        const statusTextElement = this.getElement('#gameStatusText');
        const statusBtnElement = this.getElement('#gameStatusBtn');
        
        if (status === 'won') {
          statusTextElement.textContent = translations[currentLanguage].gameWonDesc || "You've reached 2048!";
          statusBtnElement.textContent = translations[currentLanguage].keepPlaying || "Keep Playing";
          // 重新绑定点击事件
          statusBtnElement.onclick = () => {
            statusElement.classList.remove('active');
            if (window.game) {
              window.game.resumeAfterWin();
            }
          };
        } else if (status === 'gameOver') {
          statusTextElement.textContent = translations[currentLanguage].gameOverDesc || "No more moves available!";
          statusBtnElement.textContent = translations[currentLanguage].newGame || "New Game";
          // 重新绑定点击事件
          statusBtnElement.onclick = () => {
            statusElement.classList.remove('active');
            if (window.game) {
              window.game.init();
            }
          };
        }
        
        statusElement.classList.add('active');
      },

      /**
       * 更新游戏状态提示的文本
       */
      updateGameStatusText() {
        const statusElement = this.getElement('#gameStatus');
        if (statusElement.classList.contains('active')) {
          const statusTextElement = this.getElement('#gameStatusText');
          const statusBtnElement = this.getElement('#gameStatusBtn');
          
          // 根据当前显示的内容判断是胜利还是游戏结束
          const currentText = statusTextElement.textContent;
          const currentBtnText = statusBtnElement.textContent;
          
          // 检查是否是胜利状态
          const wonDescKeys = Object.values(translations).map(t => t.gameWonDesc);
          const keepPlayingKeys = Object.values(translations).map(t => t.keepPlaying);
          
          // 检查是否是游戏结束状态
          const gameOverDescKeys = Object.values(translations).map(t => t.gameOverDesc);
          const newGameKeys = Object.values(translations).map(t => t.newGame);
          
          if (wonDescKeys.includes(currentText) || keepPlayingKeys.includes(currentBtnText)) {
            // 胜利状态
            statusTextElement.textContent = translations[currentLanguage].gameWonDesc;
            statusBtnElement.textContent = translations[currentLanguage].keepPlaying;
            // 重新绑定事件
            statusBtnElement.onclick = () => {
              statusElement.classList.remove('active');
              if (window.game) {
                window.game.resumeAfterWin();
              }
            };
          } else if (gameOverDescKeys.includes(currentText) || newGameKeys.includes(currentBtnText)) {
            // 游戏结束状态
            statusTextElement.textContent = translations[currentLanguage].gameOverDesc;
            statusBtnElement.textContent = translations[currentLanguage].newGame;
            // 重新绑定事件
            statusBtnElement.onclick = () => {
              statusElement.classList.remove('active');
              if (window.game) {
                window.game.init();
              }
            };
          }
        }
      },

      /**
       * 更新UI文本
       */
      updateUI() {
        document.querySelectorAll('[data-i18n]').forEach(element => {
          const key = element.getAttribute('data-i18n');
          if (translations[currentLanguage] && translations[currentLanguage][key]) {
            // 特殊处理包含HTML的内容
            if (key === 'keyboardHint' || key === 'touchHint') {
              element.innerHTML = translations[currentLanguage][key];
            } else {
              element.textContent = translations[currentLanguage][key];
            }
          }
        });
        
        let titleText;
        if (currentLanguage === 'zh') {
          titleText = '2048 - 经典数字拼图游戏';
        } else if (currentLanguage === 'zh-TW') {
          titleText = '2048 - 經典數字拼圖遊戲';
        } else if (currentLanguage === 'ja') {
          titleText = '2048 - 古典的な数字パズルゲーム';
        } else if (currentLanguage === 'mn-Mong') {
          titleText = '2048 - ᠰᠣᠩᠭᠣᠳᠣᠭ ᠲᠣᠭᠠᠨ ᠦ ᠣᠨᠢᠰᠣᠭᠣ ᠲᠤᠭᠯᠣᠮ';
        } else {
          titleText = '2048 - Classic Number Puzzle Game';
        }
        document.getElementById('pageTitle').textContent = titleText;
        
        // 更新游戏状态提示文本
        this.updateGameStatusText();
        
        // 修复语言切换时所有开关的圆圈位置问题
        const toggleInputs = document.querySelectorAll('.theme-switch input');
        toggleInputs.forEach(input => {
          input.style.display = 'none';
        });
      }
    };

    // --- 游戏配置和设置 ---
    const config = {
      gridSize: 4,
      winningValue: 2048
    };

    const gameSettings = {
      disableAnimations: localStorage.getItem('2048-disable-animations') === 'true',
      difficulty: parseInt(localStorage.getItem('2048-difficulty')) || 2 // 1-简单, 2-中等, 3-困难
    };

    let currentLanguage = localStorage.getItem('2048-language') || 'zh';

    // --- 游戏主类 ---
    class Game2048 {
      constructor() {
        // DOM元素缓存
        this.dom = {
          gameBoard: utils.getElement('#gameBoard'),
          scoreDisplay: utils.getElement('#score'),
          bestScoreDisplay: utils.getElement('#bestScore'),
          restartBtn: utils.getElement('#restartBtn'),
          howToPlayBtn: utils.getElement('#howToPlayBtn'),
          howToPlayModal: utils.getElement('#howToPlayModal'),
          closeHowToPlayModalBtn: utils.getElement('#closeHowToPlayModalBtn'),
          startPlayingBtn: utils.getElement('#startPlayingBtn'),
          gameContainer: utils.getElement('#gameContainer'),
          settingsBtn: utils.getElement('#settingsBtn'),
          settingsModal: utils.getElement('#settingsModal'),
          closeSettingsModalBtn: utils.getElement('#closeSettingsModalBtn'),
          closeSettingsBtn: utils.getElement('#closeSettingsBtn'),
          themeToggle: null,
          disableAnimationsToggle: null,
          difficultySlider: null,
          difficultyValue: null,
          languageOptions: utils.getElements('.language-option')
        };

        // 游戏状态
        this.grid = [];
        this.score = 0;
        this.bestScore = parseInt(localStorage.getItem('2048-best-score')) || 0;
        this.gameWon = false;
        this.isProcessingMove = false;
        this.isAnimating = false;

        // 尺寸计算
        this.tileSize = 0;
        this.tileGap = 0;
        this.boardPadding = 0;

        // 初始化游戏
        this.init();
      }

      /**
       * 初始化游戏
       */
      init() {
        // 重置游戏状态
        this.grid = Array(config.gridSize).fill().map(() => Array(config.gridSize).fill(null));
        this.score = 0;
        this.gameWon = false;
        this.isProcessingMove = false;

        // 更新UI
        this.updateScoreDisplay(false);

        // 计算尺寸并渲染
        this.calculateTileSize();
        this.renderGrid();

        // 根据难度设置初始方块数量
        const startTiles = gameSettings.difficulty === 3 ? 3 : 2;
        for (let i = 0; i < startTiles; i++) {
          this.addRandomTile();
        }

        // 设置焦点
        this.dom.gameContainer.focus();
      }

      /**
       * 计算棋盘和方块尺寸
       */
      calculateTileSize() {
        const boardRect = this.dom.gameBoard.getBoundingClientRect();
        this.boardPadding = parseInt(getComputedStyle(this.dom.gameBoard).paddingLeft);
        const boardSize = Math.min(boardRect.width, boardRect.height) - (this.boardPadding * 2);
        this.tileGap = Math.floor(boardSize * 0.05);
        this.tileSize = Math.floor((boardSize - (config.gridSize - 1) * this.tileGap) / config.gridSize);
        
        // 调整棋盘尺寸以确保精确匹配
        const adjustedSize = (this.tileSize * config.gridSize) + (this.tileGap * (config.gridSize - 1)) + (this.boardPadding * 2);
        this.dom.gameBoard.style.width = `${adjustedSize}px`;
        this.dom.gameBoard.style.height = `${adjustedSize}px`;
        document.documentElement.style.setProperty('--board-width', `${adjustedSize}px`);
      }

      /**
       * 渲染棋盘格子
       */
      renderGrid() {
        this.dom.gameBoard.innerHTML = ''; // 清空棋盘
        // 添加游戏状态元素
        const statusElement = document.createElement('div');
        statusElement.id = 'gameStatus';
        statusElement.className = 'game-status text-xl font-bold';
        statusElement.innerHTML = `
          <p id="gameStatusText" class="mb-2"></p>
          <button id="gameStatusBtn" class="bg-white text-monet px-4 py-2 rounded-full font-bold hover:bg-monet-dark hover:text-white transition-all btn-hover">
            继续游戏
          </button>
        `;
        this.dom.gameBoard.appendChild(statusElement);
        
        // 创建格子
        for (let y = 0; y < config.gridSize; y++) {
          for (let x = 0; x < config.gridSize; x++) {
            const cell = document.createElement('div');
            cell.classList.add('cell');
            cell.style.width = `${this.tileSize}px`;
            cell.style.height = `${this.tileSize}px`;
            cell.style.left = `${this.boardPadding + x * (this.tileSize + this.tileGap)}px`;
            cell.style.top = `${this.boardPadding + y * (this.tileSize + this.tileGap)}px`;
            this.dom.gameBoard.appendChild(cell);
          }
        }
      }

      /**
       * 在随机空位置添加一个新方块
       * @returns {boolean} 是否成功添加
       */
      addRandomTile() {
        const availableCells = [];
        for (let y = 0; y < config.gridSize; y++) {
          for (let x = 0; x < config.gridSize; x++) {
            if (!this.grid[y][x]) {
              availableCells.push({ x, y });
            }
          }
        }
        
        if (availableCells.length === 0) return false;
        
        const cell = availableCells[Math.floor(Math.random() * availableCells.length)];
        // 根据难度调整生成4的概率
        const fourProbability = gameSettings.difficulty === 3 ? 0.3 : (gameSettings.difficulty === 2 ? 0.1 : 0.05);
        const value = Math.random() < (1 - fourProbability) ? 2 : 4;
        
        this.grid[cell.y][cell.x] = value;
        this.renderTile(cell.x, cell.y, value, true);
        
        // 检查是否达到胜利条件
        if (value === config.winningValue && !this.gameWon) {
          this.gameWon = true;
          setTimeout(() => utils.showGameStatus('won'), 500);
        }
        
        return true;
      }

      /**
       * 渲染单个方块
       * @param {number} x - x坐标
       * @param {number} y - y坐标
       * @param {number} value - 方块数值
       * @param {boolean} [isNew=false] - 是否是新方块
       * @param {boolean} [isMerged=false] - 是否是合并后的方块
       */
      renderTile(x, y, value, isNew = false, isMerged = false) {
        // 移除旧的方块
        const existingTiles = this.dom.gameBoard.querySelectorAll(`.tile[data-x="${x}"][data-y="${y}"]`);
        existingTiles.forEach(tile => tile.remove());
        
        if (value) {
          const tile = document.createElement('div');
          const tileClass = value > 2048 ? 'tile-super' : `tile-${value}`;
          
          tile.classList.add(
            'tile',
            tileClass,
            'text-xl',
            'sm:text-2xl',
            'font-bold',
            'tile-shadow'
          );
          
          tile.style.width = `${this.tileSize}px`;
          tile.style.height = `${this.tileSize}px`;
          tile.style.left = `${this.boardPadding + x * (this.tileSize + this.tileGap)}px`;
          tile.style.top = `${this.boardPadding + y * (this.tileSize + this.tileGap)}px`;
          tile.textContent = value;
          tile.dataset.x = x;
          tile.dataset.y = y;
          
          // 添加动画类
          if (isNew && !gameSettings.disableAnimations) {
            tile.classList.add('new-tile');
          }
          if (isMerged && !gameSettings.disableAnimations) {
            tile.classList.add('tile-merged');
          }
          
          this.dom.gameBoard.appendChild(tile);
          this.adjustTileFontSize(tile, value);
        }
      }

      /**
       * 根据数值调整方块字体大小
       * @param {HTMLElement} tile - 方块元素
       * @param {number} value - 方块数值
       */
      adjustTileFontSize(tile, value) {
        const textLength = String(value).length;
        let fontSize = '1.5rem';
        if (textLength === 4) {
          fontSize = '1.2rem';
        } else if (textLength >= 5) {
          fontSize = '1rem';
        }
        tile.style.fontSize = fontSize;
      }

      /**
       * 更新分数显示
       * @param {boolean} [showAnimation=true] - 是否显示分数变化动画
       */
      updateScoreDisplay(showAnimation = true) {
        this.dom.scoreDisplay.textContent = this.score;
        
        // 更新最高分
        if (this.score > this.bestScore) {
          this.bestScore = this.score;
          localStorage.setItem('2048-best-score', this.bestScore);
        }
        
        this.dom.bestScoreDisplay.textContent = this.bestScore;
        
        if (showAnimation && !gameSettings.disableAnimations) {
          this.dom.scoreDisplay.classList.add('score-change');
          setTimeout(() => {
            this.dom.scoreDisplay.classList.remove('score-change');
          }, 300);
        }
      }

      /**
       * 检查游戏是否可以移动
       * @returns {boolean} 是否可以移动
       */
      canMove() {
        // 检查是否有空位置
        for (let y = 0; y < config.gridSize; y++) {
          for (let x = 0; x < config.gridSize; x++) {
            if (this.grid[y][x] === null) {
              return true;
            }
          }
        }
        
        // 检查相邻方块是否可以合并
        for (let y = 0; y < config.gridSize; y++) {
          for (let x = 0; x < config.gridSize; x++) {
            const value = this.grid[y][x];
            if (x < config.gridSize - 1 && this.grid[y][x + 1] === value) {
              return true;
            }
            if (y < config.gridSize - 1 && this.grid[y + 1][x] === value) {
              return true;
            }
          }
        }
        
        return false;
      }

      /**
       * 处理方块移动
       * @param {string} direction - 移动方向 ('up', 'down', 'left', 'right')
       * @returns {Promise<boolean>} 是否成功移动
       */
      async move(direction) {
        if (this.isProcessingMove) return false;
        
        this.isProcessingMove = true;
        this.isAnimating = true;
        
        let moved = false;
        let scoreChanged = false;
        const movePromises = [];

        switch (direction) {
          case 'up':
            for (let x = 0; x < config.gridSize; x++) {
              for (let y = 1; y < config.gridSize; y++) {
                if (this.grid[y][x]) {
                  const moveResult = this.processMove(x, y, 0, -1, movePromises);
                  moved = moveResult.moved || moved;
                  scoreChanged = moveResult.scoreChanged || scoreChanged;
                }
              }
            }
            break;
          case 'down':
            for (let x = 0; x < config.gridSize; x++) {
              for (let y = config.gridSize - 2; y >= 0; y--) {
                if (this.grid[y][x]) {
                  const moveResult = this.processMove(x, y, 0, 1, movePromises);
                  moved = moveResult.moved || moved;
                  scoreChanged = moveResult.scoreChanged || scoreChanged;
                }
              }
            }
            break;
          case 'left':
            for (let y = 0; y < config.gridSize; y++) {
              for (let x = 1; x < config.gridSize; x++) {
                if (this.grid[y][x]) {
                  const moveResult = this.processMove(x, y, -1, 0, movePromises);
                  moved = moveResult.moved || moved;
                  scoreChanged = moveResult.scoreChanged || scoreChanged;
                }
              }
            }
            break;
          case 'right':
            for (let y = 0; y < config.gridSize; y++) {
              for (let x = config.gridSize - 2; x >= 0; x--) {
                if (this.grid[y][x]) {
                  const moveResult = this.processMove(x, y, 1, 0, movePromises);
                  moved = moveResult.moved || moved;
                  scoreChanged = moveResult.scoreChanged || scoreChanged;
                }
              }
            }
            break;
        }

        if (moved) {
          // 更新分数
          this.updateScoreDisplay(scoreChanged);
          
          // 等待所有动画完成
          if (!gameSettings.disableAnimations && movePromises.length > 0) {
            await Promise.all(movePromises);
            await new Promise(resolve => requestAnimationFrame(resolve));
          }
          
          // 添加新方块
          this.addRandomTile();
          
          // 检查游戏是否结束
          if (!this.canMove()) {
            setTimeout(() => {
              utils.showGameStatus('gameOver');
            }, 300);
          }
        }

        // 检查游戏状态
        setTimeout(() => {
          this.isAnimating = false;
          this.isProcessingMove = false;
        }, gameSettings.disableAnimations ? 0 : 300);

        return moved;
      }

      /**
       * 处理单个方块的移动逻辑
       * @param {number} x - 起始x坐标
       * @param {number} y - 起始y坐标
       * @param {number} dx - x方向增量
       * @param {number} dy - y方向增量
       * @param {Array<Promise>} movePromises - 动画Promise数组
       * @returns {object} 移动结果 { moved: boolean, scoreChanged: boolean }
       */
      processMove(x, y, dx, dy, movePromises) {
        let newX = x, newY = y;
        const value = this.grid[y][x];
        let moved = false;
        let scoreChanged = false;
        
        // 寻找可以移动到的最终位置
        while (
          newX + dx >= 0 && newX + dx < config.gridSize &&
          newY + dy >= 0 && newY + dy < config.gridSize &&
          !this.grid[newY + dy][newX + dx]
        ) {
          newX += dx;
          newY += dy;
          moved = true;
        }
        
        // 检查是否可以合并
        if (
          newX + dx >= 0 && newX + dx < config.gridSize &&
          newY + dy >= 0 && newY + dy < config.gridSize &&
          this.grid[newY + dy][newX + dx] === value
        ) {
          const targetX = newX + dx;
          const targetY = newY + dy;
          this.grid[targetY][targetX] *= 2;
          this.score += this.grid[targetY][targetX];
          this.grid[y][x] = null;
          
          // 处理合并动画
          if (!gameSettings.disableAnimations) {
            movePromises.push(this.animateTileMerge(x, y, targetX, targetY, this.grid[targetY][targetX]));
          } else {
            const originalTile = document.querySelector(`.tile[data-x="${x}"][data-y="${y}"]`);
            if (originalTile) originalTile.remove();
            this.renderTile(targetX, targetY, this.grid[targetY][targetX], false, false);
          }
          
          moved = true;
          scoreChanged = true;
          
          // 检查是否达到胜利条件
          if (this.grid[targetY][targetX] === config.winningValue && !this.gameWon) {
            this.gameWon = true;
            setTimeout(() => utils.showGameStatus('won'), 500);
          }
        } 
        // 处理单纯移动
        else if (newX !== x || newY !== y) {
          if (!gameSettings.disableAnimations) {
            movePromises.push(this.animateTileMove(x, y, newX, newY));
          } else {
            const originalTile = document.querySelector(`.tile[data-x="${x}"][data-y="${y}"]`);
            if (originalTile) originalTile.remove();
            this.renderTile(newX, newY, value, false, false);
          }
          
          this.grid[newY][newX] = value;
          this.grid[y][x] = null;
          moved = true;
        }
        
        return { moved, scoreChanged };
      }

      /**
       * 动画：方块移动
       * @param {number} fromX - 起始x坐标
       * @param {number} fromY - 起始y坐标
       * @param {number} toX - 目标x坐标
       * @param {number} toY - 目标y坐标
       * @returns {Promise} 动画完成Promise
       */
      animateTileMove(fromX, fromY, toX, toY) {
        return new Promise(resolve => {
          const tile = document.querySelector(`.tile[data-x="${fromX}"][data-y="${fromY}"]`);
          if (tile) {
            // 计算目标位置
            const targetX = this.boardPadding + toX * (this.tileSize + this.tileGap);
            const targetY = this.boardPadding + toY * (this.tileSize + this.tileGap);
            
            // 应用过渡动画
            tile.style.transition = 'left 0.2s ease, top 0.2s ease';
            tile.style.left = `${targetX}px`;
            tile.style.top = `${targetY}px`;
            
            // 更新数据属性
            tile.dataset.x = toX;
            tile.dataset.y = toY;
            
            // 动画结束后清理
            setTimeout(() => {
              tile.style.transition = '';
              resolve();
            }, 200);
          } else {
            resolve();
          }
        });
      }

      /**
       * 动画：方块合并
       * @param {number} fromX - 起始x坐标
       * @param {number} fromY - 起始y坐标
       * @param {number} toX - 目标x坐标
       * @param {number} toY - 目标y坐标
       * @param {number} value - 合并后的值
       * @returns {Promise} 动画完成Promise
       */
      animateTileMerge(fromX, fromY, toX, toY, value) {
        return new Promise(resolve => {
          const tile = document.querySelector(`.tile[data-x="${fromX}"][data-y="${fromY}"]`);
          if (tile) {
            // 计算目标位置
            const targetX = this.boardPadding + toX * (this.tileSize + this.tileGap);
            const targetY = this.boardPadding + toY * (this.tileSize + this.tileGap);
            
            // 应用过渡动画
            tile.style.transition = 'left 0.2s ease, top 0.2s ease';
            tile.style.left = `${targetX}px`;
            tile.style.top = `${targetY}px`;
            
            // 动画结束后渲染合并后的方块
            setTimeout(() => {
              tile.remove();
              this.renderTile(toX, toY, value, false, true);
              resolve();
            }, 200);
          } else {
            resolve();
          }
        });
      }

      /**
       * 窗口大小变化时重新调整
       */
      handleResize() {
        if (this.isAnimating) return;
        
        this.calculateTileSize();
        this.renderGrid();
        for (let y = 0; y < config.gridSize; y++) {
          for (let x = 0; x < config.gridSize; x++) {
            if (this.grid[y][x]) {
              this.renderTile(x, y, this.grid[y][x]);
            }
          }
        }
      }

      /**
       * 胜利后继续游戏
       */
      resumeAfterWin() {
        this.gameWon = false;
      }
    }

    // --- 事件处理和初始化 ---
    document.addEventListener('DOMContentLoaded', () => {
      // 初始化语言
      utils.updateUI();
      utils.getElements('.language-option').forEach(option => {
        option.classList.toggle('active', option.dataset.lang === currentLanguage);
      });

      // 初始化游戏实例并保存到全局变量
      const game = new Game2048();
      window.game = game; // 保存到全局变量

      // --- 语言切换事件 ---
      utils.getElements('.language-option').forEach(option => {
        option.addEventListener('click', () => {
          currentLanguage = option.dataset.lang;
          localStorage.setItem('2048-language', currentLanguage);
          utils.getElements('.language-option').forEach(opt => opt.classList.remove('active'));
          option.classList.add('active');
          utils.updateUI();
        });
      });

      // --- 主题切换功能 ---
      game.dom.themeToggle = utils.getElement('#themeToggle');
      const savedTheme = localStorage.getItem('2048-theme') || 'light';
      document.documentElement.classList.toggle('dark', savedTheme === 'dark');
      game.dom.themeToggle.checked = savedTheme === 'dark';
      game.dom.themeToggle.addEventListener('change', function() {
        document.documentElement.classList.toggle('dark', this.checked);
        localStorage.setItem('2048-theme', this.checked ? 'dark' : 'light');
      });

      // --- 动画设置功能 ---
      game.dom.disableAnimationsToggle = utils.getElement('#disableAnimationsToggle');
      game.dom.disableAnimationsToggle.checked = gameSettings.disableAnimations;
      game.dom.disableAnimationsToggle.addEventListener('change', function() {
        gameSettings.disableAnimations = this.checked;
        localStorage.setItem('2048-disable-animations', gameSettings.disableAnimations);
      });

      // --- 游戏难度设置功能 ---
      game.dom.difficultySlider = utils.getElement('#difficultySlider');
      game.dom.difficultyValue = utils.getElement('#difficultyValue');
      game.dom.difficultySlider.value = gameSettings.difficulty;
      
      function updateDifficultyDisplay() {
        const difficulty = parseInt(game.dom.difficultySlider.value);
        let difficultyKey = '';
        switch(difficulty) {
          case 1: difficultyKey = 'difficultyEasy'; break;
          case 2: difficultyKey = 'difficultyMedium'; break;
          case 3: difficultyKey = 'difficultyHard'; break;
        }
        game.dom.difficultyValue.textContent = translations[currentLanguage][difficultyKey];
      }
      
      updateDifficultyDisplay();
      game.dom.difficultySlider.addEventListener('input', updateDifficultyDisplay);
      game.dom.difficultySlider.addEventListener('change', function() {
        gameSettings.difficulty = parseInt(this.value);
        localStorage.setItem('2048-difficulty', gameSettings.difficulty);
        // 重置游戏以应用新难度
        game.init();
      });

      // --- 键盘输入处理 ---
      function handleKeydown(e) {
        // 阻止方向键和WASD键的默认滚动行为
        if ([37, 38, 39, 40, 87, 65, 83, 68].includes(e.keyCode)) {
          e.preventDefault();
        }
        switch (e.keyCode) {
          case 38: case 87: game.move('up'); break;
          case 40: case 83: game.move('down'); break;
          case 37: case 65: game.move('left'); break;
          case 39: case 68: game.move('right'); break;
        }
      }
      
      // --- 触摸输入处理 ---
      let touchStartX = 0;
      let touchStartY = 0;
      let touchStartTime = 0;
      let touchTimeout = null;
      
      function handleTouchStart(e) {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        touchStartTime = Date.now();
        if (touchTimeout) clearTimeout(touchTimeout);
      }
      
      function handleTouchMove(e) {
        e.preventDefault();
      }
      
      function handleTouchEnd(e) {
        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;
        const dx = touchEndX - touchStartX;
        const dy = touchEndY - touchStartY;
        const duration = Date.now() - touchStartTime;
        const threshold = Math.max(20, Math.min(50, game.dom.gameContainer.clientWidth * 0.1));
        
        // 判断滑动方向
        if (Math.abs(dx) > Math.abs(dy)) {
          if (dx > threshold) {
            game.move('right');
          } else if (dx < -threshold) {
            game.move('left');
          }
        } else {
          if (dy > threshold) {
            game.move('down');
          } else if (dy < -threshold) {
            game.move('up');
          }
        }
        
        // 防止短时间内多次触发
        touchTimeout = setTimeout(() => {
          touchTimeout = null;
        }, gameSettings.disableAnimations ? 0 : 200);
      }

      // --- 事件绑定 ---
      window.addEventListener('resize', () => game.handleResize());
      document.addEventListener('keydown', handleKeydown);
      
      // 触摸事件
      game.dom.gameContainer.addEventListener('touchstart', handleTouchStart);
      game.dom.gameContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
      game.dom.gameContainer.addEventListener('touchend', handleTouchEnd);
      
      // 游戏控制按钮
      game.dom.restartBtn.addEventListener('click', () => game.init());
      
      // 模态框控制
      game.dom.howToPlayBtn.addEventListener('click', () => utils.openModal('howToPlayModal'));
      game.dom.closeHowToPlayModalBtn.addEventListener('click', () => utils.closeModal('howToPlayModal'));
      game.dom.startPlayingBtn.addEventListener('click', () => utils.closeModal('howToPlayModal'));
      game.dom.howToPlayModal.addEventListener('click', (e) => {
        if (e.target === game.dom.howToPlayModal) {
          utils.closeModal('howToPlayModal');
        }
      });
      
      game.dom.settingsBtn.addEventListener('click', () => utils.openModal('settingsModal'));
      game.dom.closeSettingsModalBtn.addEventListener('click', () => utils.closeModal('settingsModal'));
      game.dom.closeSettingsBtn.addEventListener('click', () => utils.closeModal('settingsModal'));
      game.dom.settingsModal.addEventListener('click', (e) => {
        if (e.target === game.dom.settingsModal) {
          utils.closeModal('settingsModal');
        }
      });
    });
  </script>
</body>
</html>